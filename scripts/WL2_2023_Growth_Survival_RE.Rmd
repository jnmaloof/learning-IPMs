---
title: "WL2023_Size_Growth"
author: "Julin Maloof"
date: "2025-01-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Intitial attempt at making a growth/survival matrix from WL2 2023, now using random effects

```{r}
library(tidyverse)
library(tidymodels)
library(multilevelmod)
library(lmerTest)
library(broom.mixed)
library(doMC)
registerDoMC(cores = 7)
conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter", "dplyr")
conflicted::conflict_prefer("lag", "dplyr")
```

## Import the data

```{r}
growth <- read_csv("../input/WL2-2023_Size_Combined.csv")
growth
```

```{r}
survival <- read_csv("../input/WL2_Mortality.csv")
survival
```

## Wrangle Growth

We want to predict size next from size.  In the Merow examples there was a column "size" and "size next" for each time step.  I guess we are going to need to do that here.

We also should compute the interval length 

```{r}
growth2 <- growth %>% arrange(Genotype, survey_date) %>%
  select(-survey.notes, -long.leaf.cm) %>%
  group_by(Genotype) %>%
  mutate(height.cm.next = lead(height.cm),
         elapsed_days= lead(survey_date) - survey_date,
         elapsed_weeks = as.integer(elapsed_days)/7,
         survey_date_char = as.character(survey_date)) %>%
  ungroup() %>%
  drop_na(block, height.cm, height.cm.next)

growth2 
```

For easy visualization lets subset just to elapsed_days of 7

```{r}
growth2 %>%
  filter(elapsed_days==7) %>%
  ggplot(aes(x=height.cm, y=height.cm.next)) +
  geom_point(aes(color=parent.pop), alpha = 0.3) +
  geom_abline() +
  geom_smooth(method="lm")
```

Do some model comparison

Define the formula


```{r}
minSize <- min(growth2$height.cm, na.rm = TRUE)
maxSize <- max(growth2$height.cm, na.rm = TRUE)
# newdata = tibble(height.cm=seq(minSize, maxSize, length.out=101), elapsed_weeks = 1)
```


In order to be able to use the tidymodel tools on mixed effect models, it works best to add variables and formulas in the following way.  This is a bit cumbersome, but it will help later.
```{r}
lmer_spec <- linear_reg() %>%
  set_engine("lmer")

growth_wflow <- workflow() %>%
  add_variables(outcomes = height.cm.next, predictors = c(height.cm, elapsed_weeks, parent.pop, mf, block)) 

growth.models <- tibble(wflow=list(
  m1_block = {growth_wflow %>%
      add_model(lmer_spec,
                formula = height.cm.next ~ (1|block)) },
  
  m2_parent = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ (1|parent.pop) )},
  
  m3_block.parent = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ (1|parent.pop) + (1|block) )},
  
  m4_block.parent.mf = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ (1|parent.pop/mf) + (1|block) )},
  
  m5_linear.parent.mf.block = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ height.cm + (1|parent.pop/mf) + (1|block) )},
  
  m6_linear.parent.mf.block.slope = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ height.cm + (height.cm|parent.pop/mf) + (1|block) )},
  
  m7_linear.parent.mf.block.slope.slope = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ height.cm + (height.cm|parent.pop/mf) + (height.cm|block) )},
  
  # adding this after looking at m7...intercept and slope for mf have a correlation of -1.00, so remove slope from mf.
  m7_simple.linear.parent.mf.block.slope.slope = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ height.cm + (height.cm|parent.pop) + (height.cm|block) + (1|parent.pop/mf) )},
  
  m8_linear_with_weeks_int.parent = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ height.cm*elapsed_weeks + (1|parent.pop/mf) + (1|block) )},
  
  m9_linear_with_weeks_int.parent.all.slope = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ height.cm*elapsed_weeks + (height.cm + elapsed_weeks|parent.pop/mf) + (height.cm + elapsed_weeks|block) )},
  
  m10_quadratic.parent.mf.block = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ height.cm + I(height.cm^2) + (1|parent.pop/mf) + (1|block) )},
  
  m11_cubic.parent.mf.block = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ height.cm + I(height.cm^2) + I(height.cm^3) + (1|parent.pop/mf) + (1|block) )},
  
  m12_quadratic_weeks.parent.height.slope = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ height.cm*elapsed_weeks*parent.pop + I(height.cm^2) + (height.cm + I(height.cm^2) | parent.pop / mf) + (height.cm + I(height.cm^2) | block) )}, 
  
  m13_cubic_weeks.parent.height.slope = { growth_wflow %>% 
      add_model(lmer_spec,
                formula = height.cm.next ~ height.cm*elapsed_weeks*parent.pop + I(height.cm^2) + I(height.cm^3) + (height.cm + I(height.cm^2) | parent.pop) + (height.cm + I(height.cm^2) | block) )}
),
name = names(wflow)
)
```

Fit the models

```{r}
system.time( { # 55 seconds
  growth.models <- growth.models %>%
    mutate(fit = map(wflow, fit, data = growth2),
           glance = map(fit, glance)
    ) 
})

growth.models %>% select(-wflow, -fit) %>% unnest(glance) %>% arrange(BIC)
```

```{r}
growth.models %>% filter(name=="m7_linear.parent.mf.block.slope.slope") %>%
  pull(fit) %>%
  magrittr::extract2(1) %>%
  tidy()
```

```{r}
growth.models %>% filter(name=="m7_simple.linear.parent.mf.block.slope.slope") %>%
  pull(fit) %>%
  magrittr::extract2(1) %>%
  tidy()
```

```{r}
growth.models %>% filter(name=="m9_linear_with_weeks_int.parent.all.slope") %>%
  pull(fit) %>%
  magrittr::extract2(1) %>%
  tidy()
```

Concentrate on the five best models and do some cross-validation to better assess predictive power
```{r}
growth.models.best <- growth.models %>%
  unnest(glance) %>%
  slice_min(AIC, n=5) 

set.seed(1001)
growth_folds <- vfold_cv(growth2, v = 10)

growth.models.best <- growth.models.best %>%
  mutate(resamples = map(wflow, fit_resamples, resamples = growth_folds, control = control_resamples(save_pred = TRUE)))
```

```{r}
growth.models.best %>% 
  mutate(metrics = map(resamples, collect_metrics, type = "wide")) %>%
  select(name, metrics) %>%
  unnest(metrics) %>%
  select(-.config) %>%
  arrange(rmse)

```

```{r}
growth.models.best %>% 
  mutate(metrics = map(resamples, collect_metrics, type = "long")) %>%
  select(name, metrics) %>%
  unnest(metrics) %>%
  arrange(.metric, mean) %>%
  select(name, .metric, mean, std_err)

```

```{r}
growth.models.best %>% 
  mutate(metrics = map(resamples, collect_metrics, type = "long")) %>%
  select(name, metrics) %>%
  unnest(metrics) %>%
  arrange(.metric, mean) %>%
  select(name, .metric, mean, std_err) %>%
  ggplot(aes(x=name, y = mean, ymin=mean-std_err, ymax=mean+std_err, fill = name)) +
  geom_col() +
  geom_errorbar(width = 0.5) +
  facet_wrap(~.metric, scales = "free_y") +
  theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
  ggtitle("10-fold cross validation") +
  scale_fill_viridis_d()
```

So, we go with simplified m7 (or possibly m9 if we decide we need weeks).
```{r}
growth.model.final <- growth.models.best %>% filter(name == "m7_simple.linear.parent.mf.block.slope.slope") %>% pull(fit) %>% magrittr::extract2(1)

growth.model.final
```

For plotting the prediction curve, it looks like I can't combine `geom_function` and `facet_wrap` so I will compute the prediction curves myself and then combine in the plots

```{r}
newdata.growth <- growth2 %>%
  group_by(parent.pop) %>%
  summarize(minSize = min(height.cm, na.rm = TRUE),
            maxSize = max(height.cm, na.rm = TRUE)) %>%
  
  # generate a "newdata" data frame for each parent.pop
  mutate(newdata = pmap(list(parent.pop, minSize, maxSize), \(p, x, y) tibble(parent.pop = p,
                                                                              elapsed_weeks = 1,
                                                                              height.cm = seq(x, y, length.out = 101)))) %>%
  select(newdata) %>%
  unnest(newdata)

growth.predictions <- extract_fit_engine(growth.model.final) %>%
  predict(newdata.growth, re.form = ~ (height.cm | parent.pop)) %>%
  cbind(newdata.growth, height.cm.next=.)
```

Plot it.  Points are actual data (height.next vs height).  The line is the model prediction.
```{r, fig.asp=1}
growth2 %>%
  ggplot(aes(x=height.cm, y = height.cm.next)) +
  geom_point(alpha=.25) +
  geom_line(data = growth.predictions, color = "blue") +
  facet_wrap(~parent.pop, scales = "free")
```



## On to survival

Since we want to predict survival as a function of size, we need to combine the data sets

```{r}
survival2 <- survival %>% select(Genotype, death.date) %>%
  right_join(growth) %>%
  mutate(death.date = lubridate::mdy(death.date),
         surv = ifelse(is.na(death.date), 1, death.date > survey_date),
         survey_date_char = as.character(survey_date)) %>%
  
  # because we don't have height measurement on the day death is observed we need a new column, height previous
  arrange(Genotype, survey_date) %>% 
  group_by(Genotype) %>%
  mutate(height.cm.prev = lag(height.cm)) %>%
  drop_na(surv, parent.pop, height.cm.prev)

# check it
survival2 %>% select(Genotype, death.date, survey_date, surv, height.cm, height.cm.prev)
```

```{r}
survival.models <- tribble(
  ~name,          ~f,
  "1_intercept",              "surv ~ 1", 
  "2_linear_size",            "surv ~ height.cm.prev", 
  "3_linear_pops",            "surv ~ parent.pop",
  "4_linear_size_pops",       "surv ~ height.cm.prev*parent.pop",
  "5_quadratic_size",         "surv ~ height.cm.prev + I(height.cm.prev^2)", 
  "6_cubic_size",             "surv ~ height.cm.prev + I(height.cm.prev^2) + I(height.cm.prev^3)",
  "7_quadratic_size_pops",    "surv ~ height.cm.prev*parent.pop + I(height.cm.prev^2)", 
  "8_cubic_size_pops",        "surv ~ height.cm.prev*parent.pop + I(height.cm.prev^2) + I(height.cm.prev^3)"
)



survival.models <- survival.models %>%
  mutate(glm = map(f, ~ glm(as.formula(.), data = survival2, family = "binomial") ),
         predict = map(glm, predict, type = "response"), # predicting from original data...
         glance = map(glm, glance))

survival.models %>% select(-f, -glm) %>% unnest(glance) %>% arrange(BIC)
```

The cubic size model seems like the best option

```{r}
survival.model.final <- survival.models %>% filter(name == "6_cubic_size") %>% pull(glm) %>% magrittr::extract2(1)
summary(survival.model.final)
```
Since we have the same model for all pops, plotting should be easier than for the growth model
```{r}
plot_surv <- function(x, m=survival.model.final) {
  predict(m, newdata = tibble(height.cm.prev = x), type = "response")
}

survival2 %>%
  ggplot(aes(x=height.cm.prev, y = surv)) +
  geom_point(alpha=.1) + 
  geom_function(fun = plot_surv, color = "red") + 
  facet_wrap(~ parent.pop)
```

Or, plotting it all together

```{r}
survival2 %>%
  ggplot(aes(x=height.cm.prev, y = surv)) +
  geom_point(aes(color = parent.pop), alpha=.1) + 
  geom_function(fun = plot_surv, color = "red") +
  geom_smooth()
```


But...I don't think this is correct.  We have repeated measures on the same plants over different dates and that is not being considered.


Try again, including observation date in the model.

```{r}
survival.models2 <- tribble(
  ~name,          ~f,
  "1_intercept",              "surv ~ 1", 
  "2_linear_size",            "surv ~ height.cm.prev", 
  "2b_linear_size_date",            "surv ~ height.cm.prev*survey_date_char", 
  "3_linear_pops",            "surv ~ parent.pop",
  "3b_linear_pops_date",            "surv ~ parent.pop*survey_date_char",
  "4_linear_size_pops",       "surv ~ height.cm.prev*parent.pop",
  "4b_linear_size_pops_date",       "surv ~ height.cm.prev*parent.pop + height.cm.prev*survey_date_char + parent.pop*survey_date_char",
  "5_quadratic_size",         "surv ~ height.cm.prev + I(height.cm.prev^2)", 
  "5b_quadratic_size_date",         "surv ~ height.cm.prev*survey_date_char + I(height.cm.prev^2)*survey_date_char", 
  "6_cubic_size",             "surv ~ height.cm.prev + I(height.cm.prev^2) + I(height.cm.prev^3)",
  "7_quadratic_size_pops",    "surv ~ height.cm.prev*parent.pop + I(height.cm.prev^2)", 
  "8_cubic_size_pops",        "surv ~ height.cm.prev*parent.pop + I(height.cm.prev^2) + I(height.cm.prev^3)"
)



survival.models2 <- survival.models2 %>%
  mutate(glm = map(f, ~ glm(as.formula(.), data = survival2, family = "binomial") ),
         predict = map(glm, predict, type = "response"), # predicting from original data...
         glance = map(glm, glance))

survival.models2 %>% select(-f, -glm) %>% unnest(glance) %>% arrange(BIC)
```

The linear model 2b seems like the best option

```{r}
survival.model.final2 <- survival.models2 %>% filter(name == "2b_linear_size_date") %>% pull(glm) %>% magrittr::extract2(1)
summary(survival.model.final2)
```

Now we need a curve for each date

```{r}
survival_curves <- survival2 %>%
  group_by(survey_date_char) %>%
  summarize(minSize = min(height.cm, na.rm = TRUE),
            maxSize = max(height.cm, na.rm = TRUE)) %>%
  
  # generate a "newdata" data frame for each date
  mutate(newdata = pmap(list(survey_date_char, minSize, maxSize), \(d, x, y) tibble(survey_date_char = d,
                                                                                    height.cm.prev = seq(x, y, length.out = 101)))) %>%
  
  # predictions for each date
  mutate(surv = map(newdata, \(nd) predict(survival.model.final, newdata = nd, type = "response"))) %>%
  
  select(-survey_date_char) %>%
  
  # unnest to plot
  unnest(cols = c(newdata, surv), names_repair = "minimal") 

survival_curves
```

```{r, fig.asp=1}
survival2 %>%
  ggplot(aes(x=height.cm.prev, y = surv)) +
  geom_point() +
  geom_line(color = "red", data = survival_curves) +
  facet_wrap(~survey_date_char, scales = "free_x")
```
